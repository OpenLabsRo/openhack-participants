import "./chunk-5VVXMM3U.js";
import {
  add_locations,
  attribute_effect,
  check_target,
  derived,
  hmr,
  if_block,
  key,
  legacy_api,
  onDestroy,
  onMount,
  prop,
  rest_props,
  setup_stores,
  snippet,
  spread_props,
  store_get,
  transition,
  validate_store,
  writable
} from "./chunk-35XOQX74.js";
import {
  append,
  comment,
  from_html
} from "./chunk-THUBWNLS.js";
import {
  FILENAME,
  HMR,
  add_svelte_meta,
  child,
  first_child,
  get,
  getContext,
  noop,
  pop,
  proxy,
  push,
  reset,
  set,
  setContext,
  state,
  strict_equals,
  tag,
  tag_proxy,
  user_derived,
  user_effect,
  user_pre_effect
} from "./chunk-LJOH5DB2.js";
import "./chunk-D34P52HZ.js";
import "./chunk-BSQ56PJC.js";
import "./chunk-K63UQA3V.js";
import "./chunk-UGBVNEQM.js";

// node_modules/svelte5-router/dist/lib/utils.js
var PARAM = /^:(.+)/;
var SEGMENT_POINTS = 4;
var STATIC_POINTS = 3;
var DYNAMIC_POINTS = 2;
var SPLAT_PENALTY = 1;
var ROOT_POINTS = 1;
var segmentize = (uri) => uri.replace(/(^\/+|\/+$)/g, "").split("/");
var stripSlashes = (string) => string.replace(/(^\/+|\/+$)/g, "");
var rankRoute = (route, index) => {
  const score = route.default ? 0 : segmentize(route.path).reduce((score2, segment) => {
    score2 += SEGMENT_POINTS;
    if (segment === "") {
      score2 += ROOT_POINTS;
    } else if (PARAM.test(segment)) {
      score2 += DYNAMIC_POINTS;
    } else if (segment[0] === "*") {
      score2 -= SEGMENT_POINTS + SPLAT_PENALTY;
    } else {
      score2 += STATIC_POINTS;
    }
    return score2;
  }, 0);
  return { route, score, index };
};
var rankRoutes = (routes) => routes.map(rankRoute).sort((a, b) => a.score < b.score ? 1 : a.score > b.score ? -1 : a.index - b.index);
var pick = (routes, uri) => {
  let match;
  let default_;
  const [uriPathname] = uri.split("?");
  const uriSegments = segmentize(uriPathname);
  const isRootUri = uriSegments[0] === "";
  const ranked = rankRoutes(routes);
  for (let i = 0, l = ranked.length; i < l; i++) {
    const route = ranked[i].route;
    let missed = false;
    if (route.default) {
      default_ = {
        route,
        params: {},
        uri
      };
      continue;
    }
    const routeSegments = segmentize(route.path);
    const params = {};
    const max = Math.max(uriSegments.length, routeSegments.length);
    let index = 0;
    for (; index < max; index++) {
      const routeSegment = routeSegments[index];
      const uriSegment = uriSegments[index];
      if (routeSegment && routeSegment[0] === "*") {
        const splatName = routeSegment === "*" ? "*" : routeSegment.slice(1);
        params[splatName] = uriSegments.slice(index).map(decodeURIComponent).join("/");
        break;
      }
      if (typeof uriSegment === "undefined") {
        missed = true;
        break;
      }
      const dynamicMatch = PARAM.exec(routeSegment);
      if (dynamicMatch && !isRootUri) {
        const value = decodeURIComponent(uriSegment);
        params[dynamicMatch[1]] = value;
      } else if (routeSegment !== uriSegment) {
        missed = true;
        break;
      }
    }
    if (!missed) {
      match = {
        route,
        params,
        uri: "/" + uriSegments.slice(0, index).join("/")
      };
      break;
    }
  }
  return match || default_ || null;
};
var addQuery = (pathname, query) => pathname + (query ? `?${query}` : "");
var resolve = (to, base) => {
  if (to.startsWith("/"))
    return to;
  const [toPathname, toQuery] = to.split("?");
  const [basePathname] = base.split("?");
  const toSegments = segmentize(toPathname);
  const baseSegments = segmentize(basePathname);
  if (toSegments[0] === "")
    return addQuery(basePathname, toQuery);
  if (!toSegments[0].startsWith(".")) {
    const pathname = baseSegments.concat(toSegments).join("/");
    return addQuery((basePathname === "/" ? "" : "/") + pathname, toQuery);
  }
  const allSegments = baseSegments.concat(toSegments);
  const segments = [];
  allSegments.forEach((segment) => {
    if (segment === "..")
      segments.pop();
    else if (segment !== ".")
      segments.push(segment);
  });
  return addQuery("/" + segments.join("/"), toQuery);
};
var combinePaths = (basepath, path) => `${stripSlashes(path === "/" ? basepath : `${stripSlashes(basepath)}/${stripSlashes(path)}`)}/`;
var shouldNavigate = (event) => !event.defaultPrevented && event.button === 0 && !(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
var hostMatches = (anchor) => {
  const host = location.host;
  return anchor.host === host || anchor.href.indexOf(`https://${host}`) === 0 || anchor.href.indexOf(`http://${host}`) === 0;
};
var canUseDOM = () => typeof window !== "undefined" && "document" in window && "location" in window;

// node_modules/svelte5-router/dist/lib/history.js
var getLocation = (source) => {
  return {
    ...source.location,
    state: source.history.state,
    key: source.history.state && source.history.state.key || "initial"
  };
};
var createHistory = (source) => {
  const listeners = [];
  let location2 = getLocation(source);
  return {
    get location() {
      return location2;
    },
    listen(listener) {
      listeners.push(listener);
      const popstateListener = () => {
        location2 = getLocation(source);
        listener({ location: location2, action: "POP" });
      };
      source.addEventListener("popstate", popstateListener);
      return () => {
        source.removeEventListener("popstate", popstateListener);
        const index = listeners.indexOf(listener);
        listeners.splice(index, 1);
      };
    },
    navigate(to, options) {
      let { state: state2 = {}, replace = false, preserveScroll = false, blurActiveElement = false } = options ?? {};
      state2 = { ...state2, key: Date.now() + "" };
      try {
        if (replace)
          source.history.replaceState(state2, "", to);
        else
          source.history.pushState(state2, "", to);
      } catch (e) {
        source.location[replace ? "replace" : "assign"](to);
      }
      location2 = getLocation(source);
      listeners.forEach((listener) => listener({ location: location2, action: "PUSH", preserveScroll }));
      if (blurActiveElement && document.activeElement instanceof HTMLElement)
        document.activeElement.blur();
    }
  };
};
var createMemorySource = (initialPathname = "/") => {
  let index = 0;
  const stack = [{ pathname: initialPathname, search: "" }];
  const states = [];
  return {
    get location() {
      return stack[index];
    },
    addEventListener() {
    },
    removeEventListener() {
    },
    history: {
      get entries() {
        return stack;
      },
      get index() {
        return index;
      },
      get state() {
        return states[index];
      },
      pushState(state2, _, uri) {
        const [pathname, search = ""] = uri.split("?");
        index++;
        stack.push({ pathname, search });
        states.push(state2);
      },
      replaceState(state2, _, uri) {
        const [pathname, search = ""] = uri.split("?");
        stack[index] = { pathname, search };
        states[index] = state2;
      }
    }
  };
};
var globalHistory = createHistory(canUseDOM() ? window : createMemorySource());
var { navigate, listen } = globalHistory;

// node_modules/svelte5-router/dist/lib/contexts.js
var LOCATION = {};
var ROUTER = {};
var HISTORY = {};
var useInternalLocation = () => getContext(LOCATION);
var useLocation = () => getContext(LOCATION);
var useRouter = () => getContext(ROUTER);
var useHistory = () => getContext(HISTORY);

// node_modules/svelte5-router/dist/components/Link/Link.svelte
Link[FILENAME] = "node_modules/svelte5-router/dist/components/Link/Link.svelte";
var root = add_locations(from_html(`<a><!></a>`), Link[FILENAME], [[47, 0]]);
function Link($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Link);
  const $base = () => (validate_store(base, "base"), store_get(base, "$base", $$stores));
  const $location = () => (validate_store(location2, "location"), store_get(location2, "$location", $$stores));
  const [$$stores, $$cleanup] = setup_stores();
  let to = prop($$props, "to", 3, ""), replace = prop($$props, "replace", 3, false), state2 = prop($$props, "state", 19, () => ({})), getProps = prop($$props, "getProps", 3, () => ({})), preserveScroll = prop($$props, "preserveScroll", 3, false), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "click",
      "to",
      "replace",
      "state",
      "getProps",
      "preserveScroll"
    ],
    "props"
  );
  const location2 = useLocation();
  const { base } = useRouter();
  const { navigate: navigate2 } = useHistory();
  let href = tag(user_derived(() => resolve(to(), $base().uri)), "href");
  let isPartiallyCurrent = tag(user_derived(() => $location().pathname.startsWith(get(href))), "isPartiallyCurrent");
  let isCurrent = tag(user_derived(() => strict_equals(get(href), $location().pathname)), "isCurrent");
  let ariaCurrent = tag(user_derived(() => get(isCurrent) ? "page" : void 0), "ariaCurrent");
  const onClick = (event) => {
    var _a;
    (_a = $$props.click) == null ? void 0 : _a.call($$props, event);
    if (shouldNavigate(event)) {
      event.preventDefault();
      const shouldReplace = strict_equals($location().pathname, get(href)) || replace();
      navigate2(get(href), {
        state: state2(),
        replace: shouldReplace,
        preserveScroll: preserveScroll()
      });
    }
  };
  var $$exports = { ...legacy_api() };
  var a = root();
  attribute_effect(a, () => ({
    href: get(href),
    "aria-current": get(ariaCurrent),
    onclick: onClick,
    ...props
  }));
  var node = child(a);
  add_svelte_meta(() => snippet(node, () => $$props.children, () => !!get(ariaCurrent)), "render", Link, 49, 2);
  reset(a);
  append($$anchor, a);
  var $$pop = pop($$exports);
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  Link = hmr(Link, () => Link[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Link[HMR].source;
    set(Link[HMR].source, module.default[HMR].original);
  });
}
var Link_default = Link;

// node_modules/svelte5-router/dist/components/Route/Route.svelte
Route[FILENAME] = "node_modules/svelte5-router/dist/components/Route/Route.svelte";
function Route($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Route);
  const $activeRoute = () => (validate_store(activeRoute, "activeRoute"), store_get(activeRoute, "$activeRoute", $$stores));
  const [$$stores, $$cleanup] = setup_stores();
  let path = prop($$props, "path", 3, ""), rest = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "path",
      "component",
      "children"
    ],
    "rest"
  );
  let routeParams = tag(state(proxy({})), "routeParams");
  let routeProps = tag_proxy(proxy({}), "routeProps");
  const { registerRoute, unregisterRoute, activeRoute } = useRouter();
  const route = {
    path: path(),
    // If no path prop is given, this Route will act as the default Route
    // that is rendered if no other Route in the Router is a match.
    default: strict_equals(path(), "")
  };
  user_pre_effect(() => {
    if ($activeRoute() && strict_equals($activeRoute().route, route)) {
      set(routeParams, $activeRoute().params, true);
      canUseDOM() && !$activeRoute().preserveScroll && (window == null ? void 0 : window.scrollTo(0, 0));
    }
  });
  onMount(() => {
    registerRoute(route);
  });
  onDestroy(() => {
    unregisterRoute(route);
  });
  let PropComponent = $$props.component;
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          add_svelte_meta(() => PropComponent(node_2, spread_props(() => get(routeParams), () => rest)), "component", Route, 42, 4, { componentTag: "PropComponent" });
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var fragment_3 = comment();
          var node_3 = first_child(fragment_3);
          add_svelte_meta(() => snippet(node_3, () => $$props.children ?? noop, () => get(routeParams)), "render", Route, 44, 4);
          append($$anchor3, fragment_3);
        };
        add_svelte_meta(
          () => if_block(node_1, ($$render) => {
            if (PropComponent) $$render(consequent);
            else $$render(alternate, false);
          }),
          "if",
          Route,
          41,
          2
        );
      }
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($activeRoute() && strict_equals($activeRoute().route, route)) $$render(consequent_1);
      }),
      "if",
      Route,
      40,
      0
    );
  }
  append($$anchor, fragment);
  var $$pop = pop($$exports);
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  Route = hmr(Route, () => Route[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Route[HMR].source;
    set(Route[HMR].source, module.default[HMR].original);
  });
}
var Route_default = Route;

// node_modules/svelte5-router/dist/components/Router/Router.svelte
Router[FILENAME] = "node_modules/svelte5-router/dist/components/Router/Router.svelte";
var root_2 = add_locations(from_html(`<div><!></div>`), Router[FILENAME], [[159, 4]]);
function Router($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Router);
  const $base = () => (validate_store(base, "base"), store_get(base, "$base", $$stores));
  const $location = () => (validate_store(location2, "location"), store_get(location2, "$location", $$stores));
  const $routes = () => (validate_store(routes, "routes"), store_get(routes, "$routes", $$stores));
  const $activeRoute = () => (validate_store(activeRoute, "activeRoute"), store_get(activeRoute, "$activeRoute", $$stores));
  const [$$stores, $$cleanup] = setup_stores();
  let basepath = prop($$props, "basepath", 3, "/"), history = prop($$props, "history", 3, globalHistory);
  const viewtransitionFn = (node, _, direction) => {
    const vt = $$props.viewtransition(direction);
    if (strict_equals(typeof (vt == null ? void 0 : vt.fn), "function")) return vt.fn(node, vt);
    else return vt;
  };
  setContext(HISTORY, history());
  const locationContext = useInternalLocation();
  const routerContext = useRouter();
  const routes = writable([]);
  const activeRoute = writable(null);
  let hasActiveRoute = false;
  const location2 = locationContext || writable($$props.url ? { pathname: $$props.url } : history().location);
  const base = routerContext ? routerContext.routerBase : writable({ path: basepath(), uri: basepath() });
  const routerBase = derived([base, activeRoute], ([base2, activeRoute2]) => {
    if (!activeRoute2) return base2;
    const { path: basepath2 } = base2;
    const { route, uri } = activeRoute2;
    const path = route.default ? basepath2 : route.path.replace(/\*.*$/, "");
    return { path, uri };
  });
  const registerRoute = (route) => {
    const { path: basepath2 } = $base();
    let { path } = route;
    route._path = path;
    route.path = combinePaths(basepath2, path);
    if (strict_equals(typeof window, "undefined")) {
      if (hasActiveRoute) return;
      const matchingRoute = pick([route], $location().pathname);
      if (matchingRoute) {
        activeRoute.set(matchingRoute);
        hasActiveRoute = true;
      }
    } else {
      routes.update((rs) => [...rs, route]);
    }
  };
  const unregisterRoute = (route) => {
    routes.update((rs) => rs.filter((r) => strict_equals(r, route, false)));
  };
  let preserveScroll = false;
  user_effect(() => {
    const { path: basepath2 } = $base();
    routes.update(
      (rs) => rs.map((r) => {
        if (r._path) {
          return Object.assign(r, { path: combinePaths(basepath2, r._path) });
        }
        return r;
      })
      // TODO make sure this isn't undefined here
    );
  });
  user_effect(() => {
    const bestMatch = pick($routes(), $location().pathname);
    activeRoute.set(bestMatch ? { ...bestMatch, preserveScroll } : bestMatch);
  });
  if (!locationContext) {
    onMount(() => {
      const unlisten = history().listen((event) => {
        preserveScroll = event.preserveScroll || false;
        location2.set(event.location);
      });
      return unlisten;
    });
    setContext(LOCATION, location2);
  }
  setContext(ROUTER, {
    activeRoute,
    base,
    routerBase,
    registerRoute,
    unregisterRoute
  });
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node_1 = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_2 = first_child(fragment_1);
      add_svelte_meta(
        () => key(node_2, () => $location().pathname, ($$anchor3) => {
          var div = root_2();
          var node_3 = child(div);
          add_svelte_meta(() => snippet(node_3, () => $$props.children, () => $activeRoute() && $activeRoute().uri, $location), "render", Router, 160, 6);
          reset(div);
          transition(1, div, () => viewtransitionFn);
          transition(2, div, () => viewtransitionFn);
          append($$anchor3, div);
        }),
        "key",
        Router,
        158,
        2
      );
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var fragment_2 = comment();
      var node_4 = first_child(fragment_2);
      add_svelte_meta(() => snippet(node_4, () => $$props.children, () => $activeRoute() && $activeRoute().uri, $location), "render", Router, 164, 2);
      append($$anchor2, fragment_2);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        if ($$props.viewtransition) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Router,
      157,
      0
    );
  }
  append($$anchor, fragment);
  var $$pop = pop($$exports);
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  Router = hmr(Router, () => Router[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Router[HMR].source;
    set(Router[HMR].source, module.default[HMR].original);
  });
}
var Router_default = Router;

// node_modules/svelte5-router/dist/lib/actions.js
var link = (node) => {
  const onClick = (event) => {
    const anchor = event.currentTarget;
    if (anchor instanceof HTMLAnchorElement) {
      if ((anchor.target === "" || anchor.target === "_self") && hostMatches(anchor) && shouldNavigate(event)) {
        event.preventDefault();
        navigate(anchor.pathname + anchor.search, {
          replace: anchor.hasAttribute("replace"),
          preserveScroll: anchor.hasAttribute("preserveScroll")
        });
      }
    }
  };
  node.addEventListener("click", onClick);
  return {
    destroy() {
      node.removeEventListener("click", onClick);
    }
  };
};
var links = (node) => {
  const findClosest = (tagName, el) => {
    while (el && el.tagName !== tagName && el.parentElement)
      el = el.parentElement;
    return el;
  };
  const onClick = (event) => {
    if (event.target instanceof HTMLElement) {
      const anchor = findClosest("A", event.target);
      if (anchor instanceof HTMLAnchorElement) {
        if (anchor && (anchor.target === "" || anchor.target === "_self") && hostMatches(anchor) && shouldNavigate(event) && !anchor.hasAttribute("noroute")) {
          event.preventDefault();
          navigate(anchor.pathname + anchor.search, {
            replace: anchor.hasAttribute("replace"),
            preserveScroll: anchor.hasAttribute("preserveScroll")
          });
        }
      }
    }
  };
  node.addEventListener("click", onClick);
  return {
    destroy() {
      node.removeEventListener("click", onClick);
    }
  };
};
export {
  Link_default as Link,
  Route_default as Route,
  Router_default as Router,
  link,
  links,
  listen,
  navigate,
  useHistory,
  useLocation,
  useRouter
};
//# sourceMappingURL=svelte5-router.js.map
